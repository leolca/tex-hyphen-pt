\section{Patgen}\label{sec-patgen} 

\emph{Patgen} utilizes a list of hyphenated words to extract patterns and use them to define rules at various levels and lengths.
It starts with short
patterns and incrementally increases their length until reaching the maximum
pattern length allowed by the user.  The objective is to keep the patterns as
concise as possible, as this enhances their generalizability.  As it advances
and incorporates longer patterns, \emph{patgen} establishes exceptions.  In certain
cases, analyzing long patterns may be necessary, as some hyphenation points
could depend on characters far away from the breaking point\footnote{Some
    examples of hyphenation dependency on characters far from the break point:
    \emph{dem-o-crat} and \emph{de-moc-ra-cy}; \emph{as-pi-rin} and
    \emph{aspir-ing}; \emph{de-mon-stra-tive} and \emph{dem-on-stra-tion}.
}.


\emph{Patgen} works on glyph\footnote{\emph{Glyph} is commonly used in linguistics,
typography, and computer graphics to refer to a specific graphical
representation of a character or symbol, which can be the entire symbol or a
distinct visual element within it.} indices rather than character codes. Each
glyph is represented by a single byte. That amount to 256 indices, where 13 of
them are reserved for the digits 0-9 and the characters `.', `-', and `*'. The
remaining 243 are used to represent symbols of a given language.  To run
\emph{patgen}, a translation file is necessary. This file defines the values of
certain language-specific parameters (in the first line) and enumerates the
various forms in which language symbols may appear (all subsequent lines).  In
the first line, positions 1 and 2 are used to set the value of
\verb|lefthyphenmin|, and positions 3 and 4 are used to set the value of
\verb|righthyphenmin|.  These values determine the minimum length of a string
that may be generated by a hyphenation procedure. To set a single-digit value,
leave the first position blank, i.e., place a space in position 1 and 3 for
\verb|lefthyphenmin| and \verb|righthyphenmin|, respectively.  Positions 5, 6
and 7 are used to define alternative values for the special characters `.', `-'
and `*'.  
\begin{center}
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth,boxformatting={\centering}]{7}
\bitheader[lsb=1]{1-7} \\
\bitbox{2}{lefthyphenmin} & \bitbox{2}{righthyphenmin} & \bitbox{1}{.} & \bitbox{1}{-} & \bitbox{1}{*} \\
\end{bytefield}
\end{center}
The following lines use a delimiter to enclose each `letter' of the
desired language alphabet, including its alternative representations.  The
first position of the line defines the delimiter, and each symbol of the
language can occupy as many positions as necessary, as long as the reserved
value for the delimiter is not used in the symbol's definition. The defining lines ends
when the delimiter appears twice in a roll. Consider the
following example for defining the letter `e' in Portuguese:
\verb|XeXEXéXêXÉXÊX\'{e}X\^{e}X\'{E}X\^{E}XX|.
\newcommand{\bitlabel}[2]{%
    \bitbox[]{#1}{%
	\raisebox{0pt}[4ex][0pt]{%
	    \turnbox{45}{\fontsize{7}{7}\selectfont#2}%
	}%
    }%
}
\vspace{7ex}
\begin{center}
\begin{bytefield}[bitwidth=1.9em,boxformatting={\centering\tiny}]{20}
\bitlabel{1}{delimiter} & \bitlabel{1}{letter e} &
\bitlabel{1}{delimiter} & \bitlabel{1}{letter E} &
\bitlabel{1}{delimiter} & \bitlabel{1}{letter é} &
\bitlabel{1}{delimiter} & \bitlabel{1}{letter ê} &
\bitlabel{1}{delimiter} & \bitlabel{1}{letter É} &
\bitlabel{1}{delimiter} & \bitlabel{1}{letter Ê} &
\bitlabel{1}{delimiter} & \bitlabel{1}{TeX sequence for é} &
\bitlabel{1}{delimiter} & \bitlabel{1}{TeX sequence for ê} &
\bitlabel{1}{delimiter} & \bitlabel{1}{TeX sequence for É} &
\bitlabel{1}{delimiter} & \bitlabel{1}{TeX sequence for Ê} \\
\bitheader[lsb=1]{1-20} \\
\bitbox{1}{X} & \bitbox{1}{e} & \bitbox{1}{X} & \bitbox{1}{E} &
\bitbox{1}{X} & \bitbox{1}{é} & \bitbox{1}{X} & \bitbox{1}{ê} &
\bitbox{1}{X} & \bitbox{1}{É} & \bitbox{1}{X} & \bitbox{1}{Ê} &
\bitbox{1}{X} & \bitbox{1}{\textbackslash{}'\{e\}} & \bitbox{1}{X} & \bitbox{1}{\textbackslash{}\^{}\{e\}} &
\bitbox{1}{X} & \bitbox{1}{\textbackslash{}'\{E\}} & \bitbox{1}{X} & \bitbox{1}{\textbackslash{}\^{}\{E\}}
\end{bytefield}
\end{center}
%\begin{verbatim}
%XeXEXéXêXÉXÊX\'{e}X\^{e}X\'{E}X\^{E}XX 
%\end{verbatim}
We have adopted \verb|X| as the delimiter. This line represents the many ways in which the letter `e' might be found: lowercase,
uppercase, with or without acute or circumflex accents. Note that we have used
the direct input (using UTF-8 or other encoding that support the accented `e'
character) and also the compositional counterpart using the appropriate \TeX{} control sequence that
instructs \TeX{} to place accent on the letter.  In this definition, we have assumed that the many forms in
which we may find the character \emph{e} will be equivalent for
hyphenation (pattern matching) purpose. As another example, see the next line
which defines the character $\pi$ (taken from \textcite{haralambous2021}):
\verb|#p#P#\varpi ##|.
%\begin{verbatim} 
%#p#P#\varpi ## 
%\end{verbatim}

\emph{Patgen} also needs a dictionary file, which is a list of pre-hyphenated words
from which \emph{Patgen} extracts patterns to create hyphenation rules. To ensure
\emph{Patgen}'s proper functionality, the translation file and the dictionary file
must utilize the same encoding, even if it is a multi-byte encoding. The
translation file describes how to handle byte sequences representing a glyph,
and \emph{Patgen} will work seamlessly when there are at most 243 symbols in the given
language.

%Those rules are organized
%in different levels, from 1 to 9, where odd numbers represent hyphenating
%levels and even numbers represent inhibiting levels. Each level works as an
%inhibiting level of it predecessor. 
%A pattern will consist of a string made of
%characters (from the language alphabet) possibly with a number in between,
%expressing the hyphenation/inhibition level and possibly word boundaries marker
%(the period) at the pattern edges. When there is no number between characters
%in a pattern, a zero is assumed, which means \emph{undefined} and no
%hyphenation point will be suggest at that location.

The syntax to run \emph{patgen} is described in \Cref{lst-patgen-syntax}
\begin{lstlisting}[language={bash}, basicstyle=\small\ttfamily, caption={Syntax to run patgen.}, label={lst-patgen-syntax}]
patgen dictionary_file initial_pattern_set output_file translation_file
\end{lstlisting}

The dictionary file is a list of correctly hyphenated words, one per line; 
the initial pattern file is a set of hyphenation rules to be used as a starting point;
the output file is the set of final rules created by \emph{patgen}; and the translation file
which maps the many forms each symbol in a language might appear in \TeX{} documents.
If it is desired to run \emph{patgen} from scratch, starting from an empty set of rules,
just use an empty file as the initial pattern set.



\emph{Patgen} uses a few parameters along its executions: 
\begin{description}
    \item[hyph\_start, hyph\_finish]: Two numbers between 1 and 9 (separated by a space), representing the desired pattern levels
	in the final set of rules. Odd pattern levels are hyphenating levels and even pattern levels are inhibiting levels. 
	Higher level numbers prevail over lower ones, creating exceptions, exceptions over exceptions, and so on... 
	\texttt{hyph\_start} and \texttt{hyph\_finish} specify the first and last levels, respectively, to be considered during the rule creation process.

    \item[pat\_start, pat\_finish]: Patterns at each level are chosen in order of increasing pattern length (usually starting with length 2). 
	This is controlled by the parameters \texttt{pat\_start} and \texttt{pat\_finish} specified at the beginning of each level. 
	These are the minimum and maximum lengths of patterns we are interesting in. Their values range between 1 and 15.

    \item[good weight, bad weight, threshold]: Each level of patterns is tested over all words in the dictionary.
	A pattern is only if it satisfies the following formula: $\alpha \times \#\text{good matches} - \beta \times \#\text{bad matches} \geq \eta$, where
	$\alpha$ is the \texttt{good weight}, $\beta$ is the \texttt{bad weight} and $\eta$ is the \texttt{threshold}.

\end{description}



